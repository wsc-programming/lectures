<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
     var link = document.createElement( 'link' );
     link.rel = 'stylesheet';
     link.type = 'text/css';
     link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
     document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h2>WSC Lecture 20180221</h2>
          <h3>by $TeraCode</h3>
        </section>
        <section>
          <h2>Schedule</h2>
          <ul>
            <li>13:00 - 13:50 Lecture 1</li>
            <li>13:55 - 14:45 Free</li>
            <li>14:50 - 15:40 Lecture 2</li>
          </ul>
        </section>
        <section>
          <h2>Contents</h2>
          <ul>
            <li>自己紹介</li>
            <li>僕たちが提供できること</li>
            <li>今日は何を？</li>
          </ul>
        </section>
        <section>
          <h2>自己紹介</h2>
          <ul>
          </ul>
        </section>
        <section>
          <h2>僕たちが提供できること</h2>
          <ul>
            <li>プログラミングの学び方[*]</li>
            <li>エンジニアの仕事の仕組みと人生設計[*]</li>
            <li>Webの仕組み/Web技術全般[*]</li>
            <li>インフラ構築</li>
            <li>アプリケーション開発</li>
            <li>テスト駆動開発</li>
            <li>コーディング規約/リーダブルコード[*]</li>
            <li>英語/Googlability[*]</li>
            <li>数学/アルゴリズム[*]</li>
          </ul>
        </section>
        <section>
          <h2>今日は何を？</h2>
          <ul>
            <li>Lecture 1: アルゴリズムの基本</li>
            <li>Lecture 2: webサイト制作</li>
          </ul>
        </section>
        <section>
          <h1>Lecture 1</h1>
          <h3>アルゴリズム基本</h3>
        </section>
        <section>
          <h2>アルゴリズムとは</h2>
        </section>
        <section>
          <p>目的</p>
          <p>↓</p>
          <p>現状（インプット）</p>
          <p>↓</p>
          <p>解決方法<span style="font-weight:bold">（アルゴリズム）</span></p>
          <p>↓</p>
          <p>結果（アウトプット）</p>
          <p>↓</p>
          <p>目的達成</p>
        </section>
        <section>
          <h2>いろいろなアルゴリズム</h2>
          <ul>
            <li>サーチアルゴリズム：目的のデータを見つける</li>
            <li>ソートアルゴリズム：データを順番に並べる</li>
            <li>他にも、経路探索アルゴリズム、暗号化アルゴリズム、データ圧縮アルゴリズム、レイトレーシングアルゴリズムなどなど。</li>
          </ul>
        </section>
        <section>
          <h2>アルゴリズムの基本</h2>
          <ul>
            <li>順次構造</li>
            <li>分岐構造</li>
            <li>反復構造</li>
          </ul>
        </section>
        <section>
          <h2>フローチャート</h2>
        </section>
        <section data-background-image="https://www.edrawsoft.com/jp/flowchart/images/basicflow-shapes.png" data-background-size="1280px">
        </section>
        <section data-background-image="http://sevendays-study.com/algorithm/img/figpr2-3.png" data-background-size="900px">
        </section>
        <section data-background-image="http://www.cc.kyoto-su.ac.jp/~yamada/programming/ifif.png" data-background-size="1000px">
        </section>
        <section data-background-image="http://image.itmedia.co.jp/ait/articles/0808/01/r20algorithm0105.jpg" data-background-size="1000px">
        </section>
        <section>
          <h2>サーチアルゴリズム</h2>
        </section>
        <section>
          <h2>リニアサーチ</h2>
          <p>先頭から順番に探す値が見つかるまで探していく</p>
        </section>
        <section>
          <ul>
            <li>目的：配列からある値を探すこと。</li>
            <li>現状：データの「個数」、「それぞれの値」、「探す値」。</li>
            <li>結果：「探す値」があるか、どこにあるか。</li>
            <li>メリット：単純で実装しやすい。</li>
            <li>デメリット：処理速度が遅い。</li>
          </ul>
        </section>
        <section data-background-image="./img/2-1.liner_search.jpg" data-background-size="700px">
        </section>
        <section>
          <p>配列データ：　[10, 3, 1, 4, 2]</p>
          <p>探索する値：　4</p>
        </section>
        <section data-markdown>
          <code data-trim data-noescape>
            var array = [10, 3, 1, 4, 2]; // 探索する配列データ

            var searchValue = 4; //探索する値

            var findID = -1; // 見つかった時の番号。初期値はエラー  値(-1)

            // 配列のすべての値を調べる(反復)
            for(var i = 0; i < array.length ; i++){
              // 配列の値と探す値が同じなら (分岐)
              if(array[i] == searchValue){
                findID = i; // indexを保存
                break; // 繰り返しを終了
              }
            }
            console.log("見つかったindex番号は" + findID); // 探索結果を表示する。
          </code>
        </section>
        <section>
          <h2>バイナリサーチ</h2>
          <p>調べる範囲を半分に絞りながら探していく</p>
        </section>
        <section>
          <ul>
            <li>目的：配列からある値を探すこと。</li>
            <li>現状：整列済みデータの「個数」、「それぞれの値」、「探す値」。</li>
            <li>結果：「探す値」があるか、どこにあるか。</li>
            <li>メリット：処理速度が速い。</li>
            <li>デメリット：データはあらかじめ整列させておく必要あり。</li>
          </ul>
        </section>
        <section data-background-image="./img/2-2.binary_search.jpg" data-background-size="700px">
        </section>
        <section>
          <p>配列データ：　[ 1 , 2 , 4 , 5 , 6 , 8 , 9 ]</p>
          <p>探索する値：　4</p>
        </section>
        <section data-markdown>
          <code data-trim data-noescape>
            var array = [1, 2, 4, 5, 10]; // 探索するソート済み配列データ
            var searchValue = 4; // 探索する値
            var index = -1; // 見つかった番号。初期値はエラー値(-1)
            var left = 0; // 調べる左端の番号
            var right = array.length - 1; // 調べる右端の番号

            // 調べる左端と右端の間にデータがある場合繰り返す。
            while (left <= right) {

              // 左右の真ん中の番号を調べる位置にする
              middle = Math.floor((left + right) / 2);

              // 調べる位置の値と探す値を比較して
              if (array[middle] == searchValue) {

                index = middle; // 同じならその番号を保存
                break; // 繰り返しを終了

              // 探す値より小さければ
              } else if (array[middle] < searchValue) {

                left = middle + 1; // 左端を移動

                // 探す値より大きければ
              } else {

                right = middle - 1; // 右端を移動
              }
            }

            console.log(index); // 番号を表示
          </code>
        </section>
        <section>
          <h2>ソートアルゴリズム</h2>
        </section>
        <section>
          <h2>バブルソート（単純交換法）</h2>
          <p>全ての隣り合う要素の値を比べていて、小さい方を前に移動させる</p>
        </section>
        <section>
          <ul>
            <li>目的：データを昇順に並べ替える</li>
            <li>現状：データの「個数」、「それぞれの値」</li>
            <li>結果：昇降順に並んだ配列</li>
            <li>メリット：プログラムが単純で実装しやすい</li>
            <li>デメリット：処理速度が遅い</li>
          </ul>
        </section>
        <section data-background-image="https://www.opentechguides.com/images/howto/howto_5101.png" data-background-size="900px">
        </section>
        <section data-background-image="./img/2-3-1.bubble_sort.jpg" data-background-size="700px">
        </section>
        <section data-background-image="./img/2-3-2.bubble_sort.jpg" data-background-size="700px">
        </section>
        <section>
          <p>配列データ： [5 , 3 , 8 , 4 , 9]</p>
          <p>バブルソートで昇順に</p>
        </section>
        <section>
          <pre>
            <code class="javascript" data-trim data-noescape>
//ソート前の配列データ
var a = [5, 3, 8, 4, 9];

//調べる範囲の開始位置を１つずつ後ろへ移動するfor文
for (var i = 0; i < a.length; i++) {

  //後ろから前に向かって小さい値を浮かび上がらせるfor文
  for (var j = a.length - 1; j > i; j-- ) {

    //隣りあう２つの値を比べて、後ろが小さければ交換する
    if (a[j] < a[j - 1]) {
      var tmp = a[j];
      a[j] = a[j - 1];
      a[j - 1] = tmp;
    }
  }
}

console.log(a); // ソート後の配列の表示
            </code>
          </pre>
        </section>
        <section>
          <h2>選択ソート(単純選択法)</h2>
          <p>最小値を探して、先頭から順番に並べていく</p>
        </section>
        <section>
          <ul>
            <li>目的：データを昇順に並べ替える</li>
            <li>現状：データの「個数」、「それぞれの値」</li>
            <li>結果：昇順に並んだ配列</li>
            <li>メリット：プログラムが単純で実装しやすい</li>
            <li>デメリット：処理速度が遅い(バブルソートよりやや速い)</li>
          </ul>
        </section>
        <section data-background-image="https://he-s3.s3.amazonaws.com/media/uploads/2888f5b.png" data-background-size="900px">
        </section>
        <section data-background-image="./img/2-4-1.selection_sort.jpg" data-background-size="700px">
        </section>
        <section data-background-image="./img/2-4-2.selection_sort.jpg" data-background-size="700px">
        </section>
        <section>
          <p>配列データ： [7 , 5 , 4 , 2]</p>
          <p>選択ソートで昇降順に</p>
        </section>
        <section>
          <pre>
            <code class="javascript" data-trim data-noescape>
//ソート前の配列データ
var a = [7, 5, 4, 2];

//「最小値を入れる位置」を先頭から順番に選択していくfor文
for (var i = 0; i < a.length-1; i++) {

      min = a[j];
      k = j;
    }
  }
  //交換するアルゴリズム

    // 取り出した位置から前に向かって比較を繰り返し
    for (var j = i; j >= step; j -= step) {

      // 「挿入する値」が小さければ
      if (array[j - step] > tmp) {

        array[j] = array[j - step]; // step幅だけ後ろへずらす

      // 「挿入する値」が小さくなければ
      } else {

        break; // ずらす処理を終了
      }
    }

    array[j] = tmp; // ずらす処理が終わったところに「挿入する値」を入れる
  }
}

console.log("結果:" + array);
            </code>
          </pre>
        </section>
        <section>
          <h2>挿入ソート（単純挿入法）</h2>
          <p>データを抜き出して正しい位置に挿入していく方法</p>
        </section>
        <section>
          <ul>
            <li>目的：データを昇順に並べる</li>
            <li>現状：データの個数とそれぞれの値</li>
            <li>結果：昇順に並んだ配列</li>
          </ul>
          <br></br>
          <p>プログラムは単純。基本的には処理速度が遅いが、すでに整列されている部分が多いほど高速に処理できる</p>
        </section>
        <section data-background-image="https://www.codereading.com/algo_and_ds/algo/images/insertion-sort.png" data-background-size="500px">
        </section>
        <section data-background-image="./img/insertion_sort_1.jpg" data-background-size="700px">
        </section>
        <section data-background-image="./img/insertion_sort_2.jpg" data-background-size="700px">
        </section>
        <section>
          <h3>問題</h3>
          <p>配列[10, 3, 1, 4, 2]を挿入ソートで昇順に並び替えなさい。</p>
        </section>
        <section>
          <pre>
            <code class="javascript" data-trim data-noescape>
var array = [10, 3, 1, 4, 2];

// 「整列していない部分」から、順番に１つずつ取り出していく
for (var i = 1; i < array.length; i++) {

  var tmp = array[i];

  // 「整列済みの部分」のどこに挿入すればいいかを
  // 後ろから前に向かって順番に見ていく
  for (var j = i-1; j >= 0; j--) {

    // 「挿入する値」が小さければ
    if (array[j] > tmp) {

      array[j + 1] = array[j]; //調べた値を１つずつ後ろへずらす

    // 「挿入する値」が小さくなければ
    } else {

      break; //ずらす処理終了
    }
  }

  array[j + 1] = tmp; // ずらす処理が終わった位置に「挿入する値」を入れる
}

console.log("結果：" + array);
            </code>
          </pre>
        </section>
        <section>
          <h2>シェルソート</h2>
          <p>間隔をあけて挿入ソートを行い、その間隔を徐々に狭めていく方法</p>
        </section>
        <section>
          <ul>
            <li>目的：データを昇順に並べる</li>
            <li>現状：データの個数とそれぞれの値</li>
            <li>結果：昇順に並んだ配列</li>
          </ul>
          <br></br>
          <p>単純挿入法より処理速度は速いが、アルゴリズムが難しい</p>
        </section>
        <section data-background-image="https://www.codereading.com/algo_and_ds/algo/images/shell-sort.png" data-background-size="700px">
        </section>
        <section data-background-image="./img/shell_sort_1.jpg" data-background-size="700px">
        </section>
        <section data-background-image="./img/shell_sort_2.jpg" data-background-size="700px">
        </section>
        <section>
          <h3>問題</h3>
          <p>配列[10, 3, 1, 9, 7, 6, 8, 2, 4, 5]をシェルソートで昇順に並び替えなさい。</p>
        </section>
        <section>
          <pre>
            <code class="javascript" data-trim data-noescape>
var array = [10, 3, 1, 9, 7, 6, 8, 2, 4, 5];

// 「グループ分けの間隔」を半分にしていく繰り返し
for (var step = parseInt(array.length/2); step > ; step = parseInt(step/2)) {

  // 「挿入する値」を順番に１つずつ取り出す繰り返し
  for (var i = step; i < array.length; i++) {

    var tmp = array[i]; // 「挿入する値」を変数に入れて退避する

    // 取り出した位置から前に向かって比較を繰り返し
    for (var j = i; j >= step; j -= step) {

      // 「挿入する値」が小さければ
      if (array[j - step] > tmp) {

        array[j] = array[j - step]; // step幅だけ後ろへずらす

      // 「挿入する値」が小さくなければ
      } else {

        break; // ずらす処理を終了
      }
    }

    array[j] = tmp; // ずらす処理が終わったところに「挿入する値」を入れる
  }
}

console.log("結果:" + array);
            </code>
          </pre>
        </section>
        <section>
          <h2>クイックソート</h2>
          <p>再帰という考え方を使っていて名前の通り処理が速い方法</p>
        </section>
        <section>
          <ol>
            <li>真ん中にある値を基準にして、データを大小2つのグループに分割する</li>
            <li>分割したグループそれぞれに同じ処理を繰り返す</li>
          </ol>
          <br></br>
          <ul>
            <li>交換回数を減らすために交換する必要のあるもの同士で交換する</li>
            <li>アルゴリズムをシンプルにするために、「再帰」を使う</li>
          </ul>
        </section>
        <section data-background-image="./img/quicksort.jpg" data-background-size="600px">
        </section>
        <section>
          <h3>問題</h3>
          <p>配列[10, 3, 1, 9, 7, 6, 8, 2, 4, 5]をクイックソートで昇順に並び替えなさい。</p>
        </section>
        <section>
          <pre>
            <code class="javascript" data-trim data-noescape>
function quickSort(startID, endID) {
  var pivot = array[Math.floor((startID + endID) / 2)]; // 範囲の中央にある値を「ピボット」とする
  var left = startID; // 調べるleftの位置を初期値に代入
  var right = endID; // 調べるrightの位置を初期値に代入

  // ピポットより小さい値を左側へ、大きい値を右側へ分割する
  while (true) {

    // leftの値がピボットより小さければ、leftを１つ右へ進める
    while (array[left] < pivot) {
      left++;
    }

    // rightの値がピボットより小さければ、rightを１つ左へ進める
    while (array[right] > pivot) {
      right--;
    }

    // rightとleftがぶつかったら分割終了
    if (right <= left) {
      break;
    }

    var tmp = array[left];
    array[left] = array[right];
    array[right] = tmp;
    left++;
    right--;
  }

  // もし左側に分割するデータがあったら
  if (startID < left-1) {
    quickSort(startID, left-1)
  }

  // もし右側に分割するデータがあったら
  if (right+1 < endID) {
    quickSort(right+1, endID)
  }
}

array = [10, 3, 1, 9, 7, 6, 8, 2, 4, 5];

quickSort(0, array.length-1);

console.log("ソート後：" + array);
            </code>
          </pre>
        </section>
        <section>
          <h1>Lecture 2</h1>
          <h3>webの仕組み,webサイト制作</h3>
        </section>
        <section>
          <h2>webの仕組み</h2>
        </section>
        <section>
          <h3>クライアントとサーバ</h3>
          <ul>
            <li>クライアント</li>
            <li>サーバ</li>
          </ul>
        </section>
        <section>
          <ul>
            <li>インターネット接続</li>
            <li>TCP/IP</li>
            <li>DNS</li>
            <li>ドメイン</li>
            <li>http/https</li>
          </ul>
        </section>
        <section>
          <h3>処理の流れ</h3>
          <ul style="list-style: none">
            <li>ブラウザ→[URL(ドメイン)]→DNSサーバ</li>
            <li>DNSサーバ→[IPアドレス]→ブラウザ</li>
            <li>ブラウザ→[HTTPリクエスト]→サーバ</li>
            <li>サーバ→[HTTPレスポンス]→ブラウザ</li>
            <li>ブラウザでの描写</li>
          </ul>
        </section>
        <section>
          <h2>webサイト制作</h2>
        </section>
        <section>
          <h2>Steps</h2>
          <ol>
            <li>HTML/CSSが書ける</li>
            <li>localで動作を試せる</li>
            <li>gitが使える</li>
            <li>Publishできる</li>
          </ol>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
     // More info https://github.com/hakimel/reveal.js#configuration
     Reveal.initialize({
       controls: true,
       progress: true,
       history: true,
       center: true,
       transition: 'slide', // none/fade/slide/convex/concave/zoom
       // More info https://github.com/hakimel/reveal.js#dependencies
       dependencies: [
         { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
         { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
         { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
         { src: 'plugin/zoom-js/zoom.js', async: true },
         { src: 'plugin/notes/notes.js', async: true }
       ]
     });
    </script>

  </body>
</html>
